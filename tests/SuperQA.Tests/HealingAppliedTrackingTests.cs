using Microsoft.EntityFrameworkCore;
using Moq;
using Moq.Protected;
using SuperQA.Core.Entities;
using SuperQA.Infrastructure.Data;
using SuperQA.Infrastructure.Services;
using System.Net;
using Xunit;

namespace SuperQA.Tests;

/// <summary>
/// Tests to verify that AI healing only preserves locators that were actually applied to test cases,
/// not just generated by AI. This prevents the issue where the AI tries to preserve locators
/// that the user never actually applied.
/// </summary>
public class HealingAppliedTrackingTests
{
    private SuperQADbContext CreateInMemoryContext()
    {
        var options = new DbContextOptionsBuilder<SuperQADbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        var context = new SuperQADbContext(options);
        return context;
    }

    [Fact]
    public async Task HealingHistory_WhenNotApplied_IsNotUsedForProtection()
    {
        // Arrange
        var context = CreateInMemoryContext();
        var project = new Project { Id = 1, Name = "Test Project" };
        var testCase = new TestCase
        {
            Id = 1,
            ProjectId = 1,
            Title = "Test Case",
            Description = "Test",
            Steps = "Click button",
            ExpectedResults = "Success",
            AutomationScript = "await Page.ClickAsync(\"#submit-btn\");",
            Project = project
        };
        var execution = new TestExecution
        {
            Id = 1,
            TestCaseId = 1,
            ProjectId = 1,
            Status = "Failed",
            ErrorMessage = "Button not found",
            TestCase = testCase,
            Project = project
        };

        // Add healing history that was generated but NOT applied by user
        var unappliedHealing = new HealingHistory
        {
            Id = 1,
            TestCaseId = 1,
            HealingType = "AI-Healing",
            OldLocator = "#submit-btn",
            NewLocator = "[data-testid='submit']",
            WasSuccessful = true,
            WasApplied = false, // User did NOT apply this healing
            HealedAt = DateTime.UtcNow.AddDays(-1)
        };

        context.Projects.Add(project);
        context.TestCases.Add(testCase);
        context.TestExecutions.Add(execution);
        context.HealingHistories.Add(unappliedHealing);
        await context.SaveChangesAsync();

        var mockHttpMessageHandler = new Mock<HttpMessageHandler>();
        // AI response doesn't include the unapplied locator - this should NOT cause an error
        var jsonContent = "{\"choices\": [{\"message\": {\"content\": \"await Page.GetByRole(AriaRole.Button, new() { Name = \\\"Submit\\\" }).ClickAsync();\"}}]}";
        var mockResponse = new HttpResponseMessage
        {
            StatusCode = HttpStatusCode.OK,
            Content = new StringContent(jsonContent)
        };

        mockHttpMessageHandler
            .Protected()
            .Setup<Task<HttpResponseMessage>>(
                "SendAsync",
                ItExpr.IsAny<HttpRequestMessage>(),
                ItExpr.IsAny<CancellationToken>())
            .ReturnsAsync(mockResponse);

        var httpClient = new HttpClient(mockHttpMessageHandler.Object);
        var validationService = new LocatorValidationService();
        var comparisonService = new ScriptComparisonService();
        var syntaxService = new CSharpSyntaxValidationService();
        var service = new AITestHealingService(context, httpClient, validationService, comparisonService, syntaxService);

        // Act - This should NOT throw an exception because the unapplied healing should be ignored
        var result = await service.HealTestScriptAsync(1, 1, "test-api-key", "gpt-4");

        // Assert
        Assert.NotNull(result);
        Assert.Contains("GetByRole", result);
    }

    [Fact]
    public async Task HealingHistory_WhenApplied_IsUsedForProtection()
    {
        // Arrange
        var context = CreateInMemoryContext();
        var project = new Project { Id = 1, Name = "Test Project" };
        var testCase = new TestCase
        {
            Id = 1,
            ProjectId = 1,
            Title = "Test Case",
            Description = "Test",
            Steps = "Click button",
            ExpectedResults = "Success",
            AutomationScript = "await Page.ClickAsync(\"[data-testid='submit']\");",
            Project = project
        };
        var execution = new TestExecution
        {
            Id = 1,
            TestCaseId = 1,
            ProjectId = 1,
            Status = "Failed",
            ErrorMessage = "Navigation failed",
            TestCase = testCase,
            Project = project
        };

        // Add healing history that was applied by user
        var appliedHealing = new HealingHistory
        {
            Id = 1,
            TestCaseId = 1,
            HealingType = "AI-Healing",
            OldLocator = "#submit-btn",
            NewLocator = "[data-testid='submit']",
            WasSuccessful = true,
            WasApplied = true, // User DID apply this healing
            HealedAt = DateTime.UtcNow.AddDays(-1),
            AppliedAt = DateTime.UtcNow.AddDays(-1)
        };

        context.Projects.Add(project);
        context.TestCases.Add(testCase);
        context.TestExecutions.Add(execution);
        context.HealingHistories.Add(appliedHealing);
        await context.SaveChangesAsync();

        var mockHttpMessageHandler = new Mock<HttpMessageHandler>();
        // AI response removes the applied locator - this SHOULD cause an error
        var jsonContent = "{\"choices\": [{\"message\": {\"content\": \"await Page.GetByRole(AriaRole.Button, new() { Name = \\\"Submit\\\" }).ClickAsync();\"}}]}";
        var mockResponse = new HttpResponseMessage
        {
            StatusCode = HttpStatusCode.OK,
            Content = new StringContent(jsonContent)
        };

        mockHttpMessageHandler
            .Protected()
            .Setup<Task<HttpResponseMessage>>(
                "SendAsync",
                ItExpr.IsAny<HttpRequestMessage>(),
                ItExpr.IsAny<CancellationToken>())
            .ReturnsAsync(mockResponse);

        var httpClient = new HttpClient(mockHttpMessageHandler.Object);
        var validationService = new LocatorValidationService();
        var comparisonService = new ScriptComparisonService();
        var syntaxService = new CSharpSyntaxValidationService();
        var service = new AITestHealingService(context, httpClient, validationService, comparisonService, syntaxService);

        // Act & Assert - This SHOULD throw an exception because the applied healing should be protected
        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
            () => service.HealTestScriptAsync(1, 1, "test-api-key", "gpt-4"));

        Assert.Contains("Previously corrected locator", exception.Message);
    }

    [Fact]
    public async Task ApplyHealedScript_MarksHealingAsApplied()
    {
        // Arrange
        var context = CreateInMemoryContext();
        var project = new Project { Id = 1, Name = "Test Project" };
        var testCase = new TestCase
        {
            Id = 1,
            ProjectId = 1,
            Title = "Test Case",
            Description = "Test",
            Steps = "Click button",
            ExpectedResults = "Success",
            AutomationScript = "await Page.ClickAsync(\"#submit-btn\");",
            Project = project
        };

        var execution = new TestExecution
        {
            Id = 1,
            TestCaseId = 1,
            ProjectId = 1,
            Status = "Failed",
            ErrorMessage = "Button not found",
            TestCase = testCase,
            Project = project
        };

        var healedScript = "await Page.ClickAsync(\"[data-testid='submit']\");";
        
        // Create healing history that was generated but not yet applied
        var healingHistory = new HealingHistory
        {
            Id = 1,
            TestCaseId = 1,
            TestExecutionId = 1,
            HealingType = "AI-Healing",
            OldScript = testCase.AutomationScript,
            NewScript = healedScript,
            WasSuccessful = true,
            WasApplied = false, // Not yet applied
            HealedAt = DateTime.UtcNow
        };

        context.Projects.Add(project);
        context.TestCases.Add(testCase);
        context.TestExecutions.Add(execution);
        context.HealingHistories.Add(healingHistory);
        await context.SaveChangesAsync();

        var service = new TestExecutionService(context, new Microsoft.Extensions.Configuration.ConfigurationManager());

        // Act - Apply the healed script
        await service.UpdateTestCaseAutomationScriptAsync(1, healedScript, 1);

        // Assert
        var updatedHealing = await context.HealingHistories.FindAsync(1);
        Assert.NotNull(updatedHealing);
        Assert.True(updatedHealing.WasApplied, "Healing should be marked as applied");
        Assert.NotNull(updatedHealing.AppliedAt);
        Assert.True(updatedHealing.AppliedAt.Value > DateTime.UtcNow.AddSeconds(-10));
    }
}
